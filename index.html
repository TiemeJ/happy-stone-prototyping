<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Stones Tracker</title>
    <!-- Google Fonts -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;400;500;600;700&family=Exo+2:wght@100;200;300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Firebase SDKs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-firestore-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-storage-compat.min.js"></script>
    <!-- Leaflet -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <style>
        :root {
            --primary-dark: #0f1631;
            --primary-light: #1a2342;
            --primary-accent: #00e5ff;
            --secondary-accent: #9f00ff;
            --tertiary-accent: #00ff9d;
            --text-primary: #e0e6ff;
            --text-secondary: #94a0c9;
            --danger-color: #ff3860;
            --success-color: #00e676;
            --grid-color: rgba(0, 229, 255, 0.1);
            --glow-primary: 0 0 10px rgba(0, 229, 255, 0.5);
            --glow-secondary: 0 0 10px rgba(159, 0, 255, 0.5);
            --panel-border: 1px solid rgba(0, 229, 255, 0.3);
            --panel-radius: 8px;
            --neon-box-shadow: 0 0 5px rgba(0, 229, 255, 0.5), 0 0 20px rgba(0, 229, 255, 0.2);
        }

        * {
            box-sizing: border-box;
            transition: all 0.2s ease;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--primary-dark);
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(25, 35, 66, 0.8) 0%, rgba(15, 22, 49, 0.8) 100%),
                linear-gradient(rgba(0, 229, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 229, 255, 0.05) 1px, transparent 1px);
            background-size: 100% 100%, 20px 20px, 20px 20px;
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(125deg, rgba(15, 22, 49, 0) 0%, rgba(0, 229, 255, 0.05) 100%);
            pointer-events: none;
            z-index: -1;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--primary-dark);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--primary-accent);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-accent);
        }

        /* HUD Lines */
        .hud-line {
            position: fixed;
            background: linear-gradient(90deg, transparent, var(--primary-accent), transparent);
            height: 1px;
            width: 100%;
            left: 0;
            opacity: 0.3;
            z-index: -1;
        }
        
        .hud-line-top {
            top: 60px;
        }
        
        .hud-line-bottom {
            bottom: 40px;
        }
        
        .hud-corner {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 2px solid var(--primary-accent);
            opacity: 0.5;
            z-index: -1;
        }
        
        .hud-corner-tl {
            top: 20px;
            left: 20px;
            border-right: none;
            border-bottom: none;
        }
        
        .hud-corner-tr {
            top: 20px;
            right: 20px;
            border-left: none;
            border-bottom: none;
        }
        
        .hud-corner-bl {
            bottom: 20px;
            left: 20px;
            border-right: none;
            border-top: none;
        }
        
        .hud-corner-br {
            bottom: 20px;
            right: 20px;
            border-left: none;
            border-top: none;
        }

        .arrow-icon {
            background: none;
            border: none;
            color: var(--primary-accent);
        }
        
        .journey-marker-container {
            background: none;
            border: none;
        }
        
        .journey-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background-color: var(--primary-accent);
            color: var(--primary-dark);
            border-radius: 50%;
            font-weight: bold;
            font-size: 14px;
            border: 2px solid var(--text-primary);
            box-shadow: var(--neon-box-shadow);
            font-family: 'Orbitron', sans-serif;
        }
        
        .journey-marker-final {
            background-color: var(--danger-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(15, 22, 49, 0.8);
            padding: 30px;
            border-radius: var(--panel-radius);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.6);
            border: var(--panel-border);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 1;
            overflow: hidden;
        }

        .container::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--primary-accent), transparent);
            z-index: 2;
        }

        h1, h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-accent);
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--primary-accent);
        }

        h3 {
            font-family: 'Exo 2', sans-serif;
            color: var(--primary-accent);
            letter-spacing: 1px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        /* Folders section with best stone */
        .folders-section {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 15px;
            margin-bottom: 20px;
        }

        /* Folders grid */
        .folders-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .folder-card {
            background: rgba(26, 35, 66, 0.7);
            padding: 15px 10px;
            border-radius: var(--panel-radius);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 229, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            height: 140px; /* Fixed height for consistency */
        }

        .folder-card::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-accent), transparent);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .folder-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0, 229, 255, 0.2);
            border-color: var(--primary-accent);
        }

        .folder-card:hover::after {
            transform: scaleX(1);
        }

        .folder-card.active {
            border: 2px solid var(--tertiary-accent);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.3);
        }

        .folder-icon {
            font-size: 2.2em;
            color: var(--primary-accent);
            margin-bottom: 8px;
        }

        .folder-card.active .folder-icon {
            color: var(--tertiary-accent);
        }

        /* Modified to ensure "Stones" and range numbers are on separate lines */
        .folder-card h3 {
            margin: 0;
            font-size: 0.9em;
            color: var(--text-primary);
        }

        .folder-label {
            display: block; /* This forces the text to be on its own line */
            margin-bottom: 4px;
        }

        .folder-range {
            display: block; /* This forces the numbers to be on their own line */
        }

        .folder-card p {
            margin: 5px 0 0;
            font-size: 0.8em;
            color: var(--text-secondary);
        }

        /* Best stone card */
        .best-stone-card {
            background: rgba(26, 35, 66, 0.7);
            padding: 10px;
            border-radius: var(--panel-radius);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border-left: 3px solid var(--tertiary-accent);
            height: fit-content;
            width: 200px;
            display: grid;
            grid-template-columns: auto auto;
            align-items: center;
            gap: 10px;
        }
        
        .best-stone-left {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .best-stone-right {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .best-stone-photo {
            width: 70px;
            height: 70px;
            object-fit: contain;
            border-radius: 50%;
            margin: 0;
            background: transparent;
            filter: drop-shadow(0 0 8px rgba(0, 229, 255, 0.5));
            cursor: pointer;
            transition: transform 0.2s;
            border: 2px solid var(--primary-accent);
        }

        .best-stone-photo:hover {
            transform: scale(1.05);
            filter: drop-shadow(0 0 12px rgba(0, 229, 255, 0.7));
        }

        .best-stone-trophy {
            font-size: 1.4em;
            color: var(--secondary-accent);
            margin-bottom: 2px;
            text-shadow: 0 0 5px var(--secondary-accent);
        }

        .view-stone-btn {
            background: var(--tertiary-accent);
            color: var(--primary-dark);
            border: none;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 3px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Exo 2', sans-serif;
        }

        .view-stone-btn:hover {
            background: var(--primary-accent);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.5);
        }

        /* Back button */
        .back-button {
            background: rgba(26, 35, 66, 0.7);
            padding: 8px 15px;
            border-radius: 20px;
            margin-bottom: 15px;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            border: 1px solid rgba(0, 229, 255, 0.3);
            transition: all 0.3s;
            font-size: 0.9em;
            color: var(--text-primary);
            font-family: 'Exo 2', sans-serif;
        }

        .back-button:hover {
            background: rgba(0, 229, 255, 0.2);
            transform: translateX(-5px);
            box-shadow: var(--neon-box-shadow);
            border-color: var(--primary-accent);
        }

        /* Stones grid - modified for better fit */
.stones-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); /* Wider minimum */
    gap: 12px; /* Slightly reduced gap */
    margin-bottom: 20px;
}

.stone-card {
    background: rgba(26, 35, 66, 0.7);
    padding: 12px 6px; /* Reduced side padding */
    border-radius: var(--panel-radius);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(0, 229, 255, 0.2);
    cursor: pointer;
    transition: transform 0.3s, box-shadow 0.3s, border-color 0.3s;
    text-align: center;
    position: relative;
    overflow: hidden;
    height: 90px; /* Fixed height for consistency */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    min-width: 0; /* Allow shrinking below content size */
}

        .stone-card::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-accent), transparent);
            transform: scaleX(0);
            transition: transform 0.3s;
        }

        .stone-card:hover {
            transform: translateY(-3px) scale(1.03);
            border-color: var(--primary-accent);
            box-shadow: var(--neon-box-shadow);
        }

        .stone-card:hover::after {
            transform: scaleX(1);
        }

        .stone-card.active {
            border: 2px solid var(--tertiary-accent);
            background: rgba(0, 255, 157, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.2);
        }

.stone-card h3 {
    margin: 0;
    font-size: 0.85em; /* Slightly smaller */
    color: var(--text-primary);
    font-family: 'Orbitron', sans-serif;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* Add ellipsis if text overflows */
    width: 100%;
    padding: 0 2px; /* Small padding inside */
}

        .stone-card p {
            margin: 5px 0 0;
            font-size: 0.8em;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }

        #journeyMap, #allStonesMap {
            height: 400px;
            width: 100%;
            margin: 20px 0;
            border-radius: var(--panel-radius);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
            border: var(--panel-border);
            position: relative;
            overflow: hidden;
        }

        #journeyMap::before, #allStonesMap::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            pointer-events: none;
            border: 1px solid var(--primary-accent);
            box-shadow: inset 0 0 20px rgba(0, 229, 255, 0.2);
            border-radius: var(--panel-radius);
        }

        .journey-details {
            margin-top: 20px;
            padding: 20px;
            background: rgba(26, 35, 66, 0.7);
            border-radius: var(--panel-radius);
            border: var(--panel-border);
            position: relative;
        }

        .journey-entries-container {
            max-height: 600px;
            overflow-y: auto;
            transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .journey-entries-collapsed {
            max-height: 0;
            overflow: hidden;
        }

        .journey-entry {
            background: rgba(15, 22, 49, 0.7);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: var(--panel-radius);
            border-left: 4px solid var(--primary-accent);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .journey-entry::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, var(--primary-accent), transparent);
        }

        .toggle-timeline-btn {
            background: linear-gradient(135deg, var(--primary-accent), var(--tertiary-accent));
            color: var(--primary-dark);
            border: none;
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin: 15px auto;
            display: block;
            font-size: 0.9em;
            box-shadow: 0 4px 15px rgba(0, 229, 255, 0.3);
            font-family: 'Exo 2', sans-serif;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .toggle-timeline-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 229, 255, 0.5);
        }

        .toggle-timeline-btn .arrow {
            display: inline-block;
            margin-left: 5px;
            transition: transform 0.3s ease;
        }

        .toggle-timeline-btn .arrow.up {
            transform: rotate(180deg);
        }

        .recent-updates {
            background: rgba(26, 35, 66, 0.7);
            padding: 20px;
            border-radius: var(--panel-radius);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-height: 800px;
            overflow-y: auto;
            border: var(--panel-border);
            position: relative;
        }

        .update-entry {
            padding: 15px;
            margin-bottom: 15px;
            border-radius: var(--panel-radius);
            background: rgba(15, 22, 49, 0.7);
            border-left: 4px solid var(--secondary-accent);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .update-entry::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, var(--secondary-accent), transparent);
        }

        .update-content {
            width: 100%;
        }

        .update-entry h3 {
            margin: 0 0 5px 0;
            font-size: 1em;
            color: var(--primary-accent);
            font-family: 'Orbitron', sans-serif;
        }

        .update-entry p {
            margin: 5px 0;
            font-size: 0.9em;
            color: var(--text-primary);
        }

        .update-entry .timestamp {
            font-size: 0.8em;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(26, 35, 66, 0.7);
            padding: 15px;
            border-radius: var(--panel-radius);
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: var(--panel-border);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--neon-box-shadow);
        }

        .stat-card::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 10%;
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-accent), transparent);
        }

        .stat-card h3 {
            margin: 0;
            font-size: 0.9em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-card p {
            margin: 10px 0 0 0;
            font-size: 1.8em;
            color: var(--primary-accent);
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 229, 255, 0.5);
            font-family: 'Orbitron', sans-serif;
        }

        .journey-photo {
            max-width: 200px;
            border-radius: var(--panel-radius);
            margin: 10px 0;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            filter: drop-shadow(0 0 8px rgba(0, 229, 255, 0.3));
            background: transparent;
            border: 2px solid var(--primary-accent);
        }

        .journey-photo:hover {
            transform: scale(1.05);
            filter: drop-shadow(0 0 12px rgba(0, 229, 255, 0.5));
        }

        .update-photo {
            width: 100%;
            max-width: 250px;
            height: auto;
            border-radius: var(--panel-radius);
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
            margin-top: 5px;
            filter: drop-shadow(0 0 8px rgba(159, 0, 255, 0.3));
            background: transparent;
            display: block;
            border: 2px solid var(--secondary-accent);
        }

        .update-photo:hover {
            transform: scale(1.02);
            filter: drop-shadow(0 0 12px rgba(159, 0, 255, 0.5));
        }

/* Photo modal container */
.photo-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 22, 49, 0.95);
    z-index: 10000;
    justify-content: center;
    align-items: flex-start;
    backdrop-filter: blur(5px);
    padding-top: 10%; /* Dynamic padding will be applied via JavaScript */
    box-sizing: border-box;
}

/* Modal content container */
.modal-content {
    /* Size will be set dynamically via JavaScript */
    position: relative;
    background: transparent;
    z-index: 10001;
    border: 2px solid var(--primary-accent);
    border-radius: var(--panel-radius);
    overflow: hidden;
    box-shadow: 0 0 30px rgba(0, 229, 255, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    padding: 0;
}

/* Modal content image */
.modal-content img {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    border-radius: calc(var(--panel-radius) - 2px);
    filter: drop-shadow(0 0 20px rgba(0, 229, 255, 0.3));
    background: transparent;
    display: block;
    object-fit: contain;
    margin: 0;
}

/* Close button styling */
.close-modal {
    position: absolute;
    top: 10px;
    right: 10px;
    color: var(--primary-accent);
    font-size: 30px;
    cursor: pointer;
    background: rgba(15, 22, 49, 0.7);
    border: 1px solid var(--primary-accent);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    transition: all 0.3s;
    z-index: 10002;
    text-shadow: 0 0 10px var(--primary-accent);
}

.close-modal:hover {
    transform: rotate(90deg) scale(1.2);
    color: var(--tertiary-accent);
    border-color: var(--tertiary-accent);
}

/* Added glow effect to modal border for better visibility */
.modal-content::before {
    content: "";
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, var(--primary-accent), var(--secondary-accent), var(--tertiary-accent), var(--primary-accent));
    background-size: 400% 400%;
    z-index: -1;
    border-radius: calc(var(--panel-radius) + 2px);
    opacity: 0.7;
    animation: gradient-border 3s ease infinite;
    pointer-events: none;
}

/* Phone-specific adjustments */
@media (max-width: 600px) {
    .photo-modal {
        padding-top: 10px; /* Minimal top padding on phones */
    }
    
    .modal-content {
        max-width: 90%; /* Even wider on phones */
        max-height: 70vh; /* More vertical space on phones */
    }
    
    .modal-content img {
        max-height: 65vh; /* Allow more height on phones */
    }
}

        @keyframes gradient-border {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .modal-content img {
            max-width: 100%;
            max-height: 70vh; /* Ensure image fits within viewport */
            border-radius: var(--panel-radius);
            filter: drop-shadow(0 0 20px rgba(0, 229, 255, 0.3));
            background: transparent;
            display: block;
            object-fit: contain; /* Maintain aspect ratio */
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 10px;
            color: var(--primary-accent);
            font-size: 30px;
            cursor: pointer;
            background: rgba(15, 22, 49, 0.7);
            border: 1px solid var(--primary-accent);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: all 0.3s;
            z-index: 10002;
            text-shadow: 0 0 10px var(--primary-accent);
        }

        .close-modal:hover {
            transform: rotate(90deg) scale(1.2);
            color: var(--tertiary-accent);
            border-color: var(--tertiary-accent);
        }

        .loading-indicator {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 22, 49, 0.9);
            padding: 30px;
            border-radius: var(--panel-radius);
            box-shadow: 0 0 30px rgba(0, 229, 255, 0.5);
            z-index: 10000;
            border: 2px solid var(--primary-accent);
            color: var(--primary-accent);
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .loading-indicator::after {
            content: "";
            position: absolute;
            width: 40px;
            height: 40px;
            top: calc(50% - 20px);
            left: calc(50% - 20px);
            border: 3px solid transparent;
            border-top-color: var(--primary-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Admin upload section */
        .admin-upload-section {
            background: rgba(15, 22, 49, 0.7);
            padding: 20px;
            margin: 20px 0;
            border-radius: var(--panel-radius);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: var(--panel-border);
            position: relative;
            overflow: hidden;
        }

        .admin-upload-section h3 {
            margin-top: 0;
            color: var(--primary-accent);
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .file-input-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .file-input-container input[type="file"] {
            display: none;
        }

        .custom-file-upload {
            display: block;
            padding: 8px 16px;
            cursor: pointer;
            background: rgba(0, 229, 255, 0.1);
            border-radius: 20px;
            border: 1px solid var(--primary-accent);
            font-size: 0.9em;
            transition: all 0.3s;
            text-align: center;
            margin-bottom: 10px;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Exo 2', sans-serif;
        }

        .custom-file-upload:hover {
            background: rgba(0, 229, 255, 0.2);
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
            transform: translateY(-2px);
        }

        .upload-btn {
            background: linear-gradient(135deg, var(--primary-accent), var(--tertiary-accent));
            color: var(--primary-dark);
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Exo 2', sans-serif;
        }

        .upload-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.5);
        }

        .upload-btn:disabled {
            background: linear-gradient(135deg, #2a3a5a, #464d69);
            color: var(--text-secondary);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .file-name {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .stone-feature-image {
            max-width: 150px;
            max-height: 150px;
            object-fit: contain;
            border-radius: 50%;
            margin: 10px auto;
            cursor: pointer;
            transition: transform 0.3s, filter 0.3s;
            filter: drop-shadow(0 0 10px rgba(0, 229, 255, 0.4));
            background: transparent;
            display: block;
            border: none;
            border: 2px solid var(--primary-accent);
        }

        .stone-feature-image:hover {
            transform: scale(1.08) rotate(5deg);
            filter: drop-shadow(0 0 15px rgba(0, 229, 255, 0.7));
        }

        .feature-photo-container {
            background: rgba(0, 255, 157, 0.05) !important;
            border-left: 4px solid var(--tertiary-accent) !important;
            text-align: center;
        }

        .stone-placeholder {
            width: 150px;
            height: 150px;
            margin: 5px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(26, 35, 66, 0.5);
            border: 2px dashed var(--primary-accent);
            box-shadow: inset 0 0 20px rgba(0, 229, 255, 0.1);
            position: relative;
        }

        .stone-placeholder::after {
            content: "";
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border-radius: 50%;
            background: conic-gradient(
                transparent 0deg, 
                transparent 45deg, 
                var(--primary-accent) 45deg,
                var(--primary-accent) 90deg,
                transparent 90deg
            );
            animation: rotate 10s linear infinite;
            opacity: 0.2;
            z-index: -1;
        }

        @keyframes rotate {
            to { transform: rotate(360deg); }
        }

        .journey-summary {
            background: rgba(15, 22, 49, 0.7);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: var(--panel-radius);
            border-left: 4px solid var(--secondary-accent);
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .journey-summary::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(159, 0, 255, 0.05) 0%, transparent 100%);
            pointer-events: none;
        }

        .journey-summary-info {
            flex: 1;
        }

        .journey-summary-info h3 {
            margin: 0 0 5px 0;
            font-size: 1em;
            color: var(--secondary-accent);
            text-shadow: 0 0 5px rgba(159, 0, 255, 0.5);
        }

        .journey-summary-info p {
            margin: 0;
            font-size: 0.9em;
            color: var(--text-primary);
        }
        
        /* Art Gallery Styles */
        .art-gallery-section {
            margin-top: 40px;
            padding: 20px;
            background: rgba(26, 35, 66, 0.7);
            border-radius: var(--panel-radius);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: var(--panel-border);
            position: relative;
            overflow: hidden;
        }
        
        .art-gallery-section::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--primary-accent), transparent);
        }
        
        .gallery-controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        
        .range-button {
            background: rgba(15, 22, 49, 0.7);
            border: 1px solid var(--primary-accent);
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
            color: var(--text-primary);
            font-family: 'Exo 2', sans-serif;
            letter-spacing: 1px;
        }
        
        .range-button:hover {
            background: rgba(0, 229, 255, 0.1);
            transform: translateY(-3px);
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
        }
        
        .range-button.active {
            background: linear-gradient(135deg, var(--primary-accent), var(--tertiary-accent));
            border-color: transparent;
            color: var(--primary-dark);
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.4);
        }
        
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .gallery-item {
            position: relative;
            height: 180px;
            border-radius: var(--panel-radius);
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            background: rgba(15, 22, 49, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--primary-accent);
        }
        
        .gallery-item:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.4);
            z-index: 1;
        }
        
        .gallery-item::before {
            content: "";
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--primary-accent), var(--secondary-accent), var(--tertiary-accent), var(--primary-accent));
            background-size: 400% 400%;
            z-index: -1;
            opacity: 0;
            border-radius: calc(var(--panel-radius) + 2px);
            transition: opacity 0.3s;
        }
        
        .gallery-item:hover::before {
            opacity: 0.7;
            animation: gradient-border 3s ease infinite;
        }
        
        .gallery-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: transparent;
            filter: drop-shadow(0 0 10px rgba(0, 229, 255, 0.3));
            cursor: pointer;
            transition: transform 0.3s;
            padding: 5px;
        }
        
        .gallery-item:hover .gallery-image {
            transform: scale(1.05);
        }
        
        .gallery-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            background: rgba(26, 35, 66, 0.5);
            color: var(--text-secondary);
            border-radius: var(--panel-radius);
        }
        
        .gallery-caption {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(15, 22, 49, 0.9);
            color: var(--primary-accent);
            padding: 5px 8px;
            font-size: 0.9em;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            backdrop-filter: blur(5px);
            border-top: 1px solid rgba(0, 229, 255, 0.3);
        }
        
        .no-photos-message {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px;
            background: rgba(15, 22, 49, 0.7);
            border-radius: var(--panel-radius);
            color: var(--text-secondary);
            border: 1px dashed var(--primary-accent);
        }
        
        /* Statistics Section Styles */
        .statistics-section {
            margin-top: 40px;
            padding: 20px;
            background: rgba(26, 35, 66, 0.7);
            border-radius: var(--panel-radius);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: var(--panel-border);
            position: relative;
            overflow: hidden;
        }
        
        .statistics-section::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--secondary-accent), transparent);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-box {
            background: rgba(15, 22, 49, 0.7);
            border-radius: var(--panel-radius);
            padding: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border-left: 3px solid var(--primary-accent);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .stat-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
        }
        
        .stat-box::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at top left, rgba(0, 229, 255, 0.1) 0%, transparent 70%);
            pointer-events: none;
        }
        
        .stat-box h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-box .value {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--primary-accent);
            margin: 0 0 5px 0;
            text-shadow: 0 0 5px rgba(0, 229, 255, 0.5);
            font-family: 'Orbitron', sans-serif;
        }
        
        .stat-box .subtitle {
            font-size: 0.8em;
            color: var(--text-secondary);
            margin: 0;
        }
        
        .chart-container {
            height: 400px;
            margin: 30px 0;
            position: relative;
            background: rgba(15, 22, 49, 0.7);
            border-radius: var(--panel-radius);
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: var(--panel-border);
        }
        
        .top-performers {
            margin-top: 40px;
        }
        
        .bar-image-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80px;
            z-index: 10;
        }
        
        .bar-image {
            width: 70px;
            height: 70px;
            object-fit: contain;
            border-radius: 50%;
            border: 3px solid var(--primary-accent);
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.4);
            background: rgba(15, 22, 49, 0.8);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .bar-image:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.6);
            border-color: var(--tertiary-accent);
        }
        
        .geo-chart {
            margin-top: 30px;
        }
        
        .month-activity-chart {
            margin-top: 30px;
        }

        /* Leaflet Custom Styling */
        .leaflet-container {
            background: #0a0e1f !important;
        }
        
        .leaflet-control-zoom a {
            background-color: rgba(26, 35, 66, 0.9) !important;
            color: var(--primary-accent) !important;
            border-color: var(--primary-accent) !important;
        }
        
        .leaflet-control-zoom a:hover {
            background-color: rgba(0, 229, 255, 0.2) !important;
        }
        
        .leaflet-control-attribution {
            background-color: rgba(15, 22, 49, 0.8) !important;
            color: var(--text-secondary) !important;
        }
        
        .leaflet-control-attribution a {
            color: var(--primary-accent) !important;
        }
        
        .leaflet-popup-content-wrapper {
            background: rgba(15, 22, 49, 0.9) !important;
            border: 1px solid var(--primary-accent) !important;
            border-radius: var(--panel-radius) !important;
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.3) !important;
        }
        
        .leaflet-popup-tip {
            background: var(--primary-accent) !important;
        }
        
        .leaflet-popup-content {
            color: var(--text-primary) !important;
            margin: 10px 12px !important;
        }
        
        /* Custom scrollbars for elements with overflow */
        .journey-entries-container::-webkit-scrollbar,
        .recent-updates::-webkit-scrollbar {
            width: 5px;
        }
        
        .journey-entries-container::-webkit-scrollbar-track,
        .recent-updates::-webkit-scrollbar-track {
            background: rgba(15, 22, 49, 0.5);
        }
        
        .journey-entries-container::-webkit-scrollbar-thumb,
        .recent-updates::-webkit-scrollbar-thumb {
            background: var(--primary-accent);
            border-radius: 3px;
        }

        @media (max-width: 768px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 15px;
            }

            .journey-photo, .stone-feature-image {
                max-width: 100%;
            }
            
            .folders-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            }
            
            .folders-section {
                grid-template-columns: 1fr;
            }
            
            .stats, .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .close-modal {
                top: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- HUD Elements -->
    <div class="hud-line hud-line-top"></div>
    <div class="hud-line hud-line-bottom"></div>
    <div class="hud-corner hud-corner-tl"></div>
    <div class="hud-corner hud-corner-tr"></div>
    <div class="hud-corner hud-corner-bl"></div>
    <div class="hud-corner hud-corner-br"></div>

    <div class="container">
        <h1><i class="fas fa-satellite"></i> COSMIC STONES TRACKER</h1>
        
        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="loading-indicator">
            SCANNING DATA
        </div>

        <!-- Photo Modal -->
        <div id="photoModal" class="photo-modal">
            <div class="modal-content">
                <button class="close-modal" onclick="closePhotoModal()">×</button>
                <img id="modalImage" src="" alt="Stone location">
            </div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <h3>Total Stones</h3>
                <p id="totalStones">0</p>
            </div>
            <div class="stat-card">
                <h3>Total Journeys</h3>
                <p id="totalJourneys">0</p>
            </div>
            <div class="stat-card">
                <h3>Active This Month</h3>
                <p id="activeStones">0</p>
            </div>
        </div>

        <div class="dashboard-grid">
            <div class="recent-updates">
                <h2>TRANSMISSION LOG</h2>
                <div id="recentUpdates"></div>
            </div>

            <div class="main-content">
                <!-- Folders view -->
                <div id="foldersView">
                    <h2>STONE ARCHIVES</h2>
                    <div class="folders-section">
                        <div class="folders-grid" id="foldersGrid"></div>
                        <div class="best-stone-card" id="bestStoneCard">
                            <div class="best-stone-left">
                                <div class="best-stone-trophy"><i class="fas fa-award"></i></div>
                                <h3 style="margin: 0 0 2px 0; font-size: 0.85em;">PRIME SPECIMEN</h3>
                                <div id="bestStoneInfo">...</div>
                            </div>
                            <div id="bestStonePhoto" class="best-stone-right">Loading...</div>
                        </div>
                    </div>
                </div>
                
                <!-- Stones view (initially hidden) -->
                <div id="stonesView" style="display: none;">
                    <div class="back-button" onclick="showFolders()">
                        <span><i class="fas fa-chevron-left"></i></span> RETURN TO ARCHIVES
                    </div>
                    <h2 id="currentFolderTitle">STONES</h2>
                    <div class="stones-grid" id="stonesGrid"></div>
                </div>
                
                <div class="map-container" style="display: flex; gap: 20px; margin: 20px 0;">
                    <div style="flex: 1;">
                        <h3 style="margin-top: 0; text-align: center;"><i class="fas fa-route"></i> STONE TRAJECTORY</h3>
                        <div id="journeyMap" style="height: 400px;"></div>
                    </div>
                    <div style="flex: 1;">
                        <h3 style="margin-top: 0; text-align: center;"><i class="fas fa-globe"></i> GLOBAL NETWORK</h3>
                        <div id="allStonesMap" style="height: 400px;"></div>
                    </div>
                </div>
                <div class="journey-details" id="journeyDetails"></div>
            </div>
        </div>
        
        <!-- Art Gallery Section -->
        <div class="art-gallery-section">
            <h2><i class="fas fa-flask"></i> SPECIMEN GALLERY</h2>
            <p style="text-align: center; color: var(--text-secondary); margin-bottom: 20px;">View all stone specimens in holographic display. Select a range to filter specimens.</p>
            
            <div class="gallery-controls" id="galleryRangeSelector">
                <!-- Range buttons will be added dynamically -->
            </div>
            
            <div class="gallery-grid" id="galleryGrid">
                <div class="no-photos-message">
                    <p>SELECT SPECIMEN RANGE FOR ANALYSIS</p>
                </div>
            </div>
        </div>
        
        <!-- Statistics Section -->
        <div class="statistics-section">
            <h2><i class="fas fa-chart-bar"></i> ANALYTICS TERMINAL</h2>
            <p style="text-align: center; color: var(--text-secondary); margin-bottom: 20px;">Advanced metrics and deep scan analysis of the cosmic stone collection.</p>
            
            <!-- Key Stats Grid -->
            <div class="stats-grid" id="statsGrid">
                <!-- Stats boxes will be added dynamically -->
            </div>
            
            <!-- Top Performers Chart -->
            <div class="top-performers">
                <h3 style="margin-bottom: 10px; text-align: center;">TOP 3 ENERGY SIGNATURES</h3>
                <p style="text-align: center; color: var(--text-secondary); margin-bottom: 20px;">Specimens with highest journey frequencies</p>
                <div class="chart-container" id="topPerformersChart"></div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Firebase first
        const firebaseConfig = {
            apiKey: "AIzaSyBVMOTMubOV8Y1iEpK-E0TqZC5MptS6jpk",
            authDomain: "happy-stone-tracker.firebaseapp.com",
            projectId: "happy-stone-tracker",
            storageBucket: "happy-stone-tracker.firebasestorage.app",
            messagingSenderId: "454968587977",
            appId: "1:454968587977:web:cce4e67177cdf8029ebf18",
            measurementId: "G-CV38E0V9E4"
        };

        // Initialize Firebase
        const app = firebase.initializeApp(firebaseConfig);
        
        // Initialize Firestore and Storage after app initialization
        const db = firebase.firestore();
        const storage = firebase.storage();
        let currentMap = null;
        let allStonesMap = null;
        let activeStoneId = null;
        let selectedFile = null;
        let currentFolderId = null;
        let allStones = []; // Store all stones data
        let allStonesMarkers = []; // Store markers for all stones

        // Loading indicator functions - sci-fi style
        function showLoading() {
            const loadingElement = document.getElementById('loadingIndicator');
            loadingElement.style.display = 'block';
            
            // Add animated dots to the loading text
            let dots = 0;
            const loadingInterval = setInterval(() => {
                if (loadingElement.style.display === 'none') {
                    clearInterval(loadingInterval);
                    return;
                }
                
                dots = (dots + 1) % 4;
                let dotText = '';
                for (let i = 0; i < dots; i++) {
                    dotText += '.';
                }
                loadingElement.innerHTML = `SCANNING DATA${dotText}`;
            }, 300);
        }

        function hideLoading() {
            document.getElementById('loadingIndicator').style.display = 'none';
        }

        // Function to show folders view and hide stones view
        function showFolders() {
            document.getElementById('foldersView').style.display = 'block';
            document.getElementById('stonesView').style.display = 'none';
            currentFolderId = null;
            
            // Remove active class from all folder cards
            document.querySelectorAll('.folder-card').forEach(card => {
                card.classList.remove('active');
            });
        }

        // Function to show stones in a specific folder
        function showStonesInFolder(folderId, folderName) {
            currentFolderId = folderId;
            
            console.log(`Opening folder ${folderId}: ${folderName}`);
            
            // Update active folder
            document.querySelectorAll('.folder-card').forEach(card => {
                card.classList.remove('active');
                if (card.dataset.folderId === folderId) {
                    card.classList.add('active');
                }
            });
            
            // Update folder title
            document.getElementById('currentFolderTitle').textContent = folderName;
            
            // Show stones view, hide folders view
            document.getElementById('foldersView').style.display = 'none';
            document.getElementById('stonesView').style.display = 'block';
            
            // Clear stones grid
            const stonesGrid = document.getElementById('stonesGrid');
            stonesGrid.innerHTML = '';
            
            // Filter stones for this folder and display them
            const [minStone, maxStone] = folderId.split('-').map(Number);
            
            console.log(`Filtering stones for range ${minStone}-${maxStone}`);
            
            const folderStones = allStones.filter(stone => {
                // Extract numeric part from stone ID (handles both numeric IDs and IDs with prefixes)
                const stoneIdStr = stone.id.toString();
                const numericPart = stoneIdStr.replace(/\D/g, '');
                const stoneNum = parseInt(numericPart);
                
                // Debug log
                console.log(`Stone ${stoneIdStr}, numeric value: ${stoneNum}, in range ${minStone}-${maxStone}? ${stoneNum >= minStone && stoneNum <= maxStone}`);
                
                if (isNaN(stoneNum)) return false;
                return stoneNum >= minStone && stoneNum <= maxStone;
            });
            
            console.log(`Found ${folderStones.length} stones for folder ${folderId}`);
            
            // Sort stones by ID
            folderStones.sort((a, b) => {
                const numA = parseInt(a.id.toString().replace(/\D/g, ''));
                const numB = parseInt(b.id.toString().replace(/\D/g, ''));
                return numA - numB;
            });
            
            // Create and append stone cards
            folderStones.forEach(stone => {
                stonesGrid.appendChild(stone.card);
            });
        }

        async function getCoordinates(locationString) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationString)}`);
                const data = await response.json();
                if (data.length > 0) {
                    return {
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon)
                    };
                }
                return null;
            } catch (error) {
                console.error("Error geocoding location:", error);
                return null;
            }
        }

        // Toggle timeline visibility
        function toggleTimeline() {
            const entriesContainer = document.getElementById('journeyEntriesContainer');
            const toggleButton = document.getElementById('toggleTimelineBtn');
            const arrow = toggleButton.querySelector('.arrow');
            
            if (entriesContainer.classList.contains('journey-entries-collapsed')) {
                // Expand timeline
                entriesContainer.classList.remove('journey-entries-collapsed');
                toggleButton.innerHTML = '<i class="fas fa-clock"></i> HIDE TEMPORAL DATA <span class="arrow up">▼</span>';
                
                // Scroll to the entries container (with a small delay to allow for the animation)
                setTimeout(() => {
                    entriesContainer.scrollIntoView({behavior: 'smooth', block: 'start'});
                }, 100);
            } else {
                // Collapse timeline
                entriesContainer.classList.add('journey-entries-collapsed');
                toggleButton.innerHTML = '<i class="fas fa-clock"></i> SHOW TEMPORAL DATA <span class="arrow">▼</span>';
                
                // Scroll back to the summary section
                const journeyDetails = document.getElementById('journeyDetails');
                journeyDetails.scrollIntoView({behavior: 'smooth', block: 'start'});
            }
        }

function openPhotoModal(url) {
    const modal = document.getElementById('photoModal');
    const modalImg = document.getElementById('modalImage');
    const modalContent = document.querySelector('.modal-content');
    const closeBtn = document.querySelector('.close-modal');
    
    // Hide map controls when opening modal
    document.querySelectorAll('.leaflet-control-container').forEach(control => {
        control.style.visibility = 'hidden';
    });
    
    // Force scroll to top of page before showing modal
    window.scrollTo(0, 0);
    document.body.style.overflow = 'hidden'; // Prevent scrolling when modal is open
    
    // Reset any previous inline styles
    modalContent.style = '';
    modalImg.style = '';
    
    // Show the modal first with loading indicator
    modal.style.display = 'flex';
    
    // Add a loading indicator
    const loadingIndicator = document.createElement('div');
    loadingIndicator.style.position = 'absolute';
    loadingIndicator.style.top = '50%';
    loadingIndicator.style.left = '50%';
    loadingIndicator.style.transform = 'translate(-50%, -50%)';
    loadingIndicator.style.color = 'var(--primary-accent)';
    loadingIndicator.style.fontSize = '1.5em';
    loadingIndicator.innerHTML = '<i class="fas fa-sync fa-spin"></i>';
    modalContent.appendChild(loadingIndicator);
    
    // Pre-load the image to get its natural dimensions
    const tempImg = new Image();
    tempImg.onload = function() {
        // Remove loading indicator
        if (loadingIndicator.parentNode) {
            loadingIndicator.parentNode.removeChild(loadingIndicator);
        }
        
        // Get image natural dimensions
        const imgWidth = tempImg.width;
        const imgHeight = tempImg.height;
        const aspectRatio = imgWidth / imgHeight;
        
        // Calculate the available space (accounting for zoom level)
        const availableWidth = window.innerWidth * 0.9; // 90% of window width
        const availableHeight = window.innerHeight * 0.8; // 80% of window height
        
        // Calculate padding (for top spacing)
        const topPadding = window.innerHeight * 0.1; // 10% of window height
        modal.style.paddingTop = `${topPadding}px`;
        
        // Calculate optimal dimensions that will fit within available space
        let finalWidth, finalHeight;
        
        if (aspectRatio > 1) { // Landscape image
            // Start with filling available width
            finalWidth = Math.min(availableWidth, imgWidth);
            finalHeight = finalWidth / aspectRatio;
            
            // If height exceeds available height, scale down
            if (finalHeight > availableHeight) {
                finalHeight = availableHeight;
                finalWidth = finalHeight * aspectRatio;
            }
        } else { // Portrait image
            // Start with filling available height
            finalHeight = Math.min(availableHeight, imgHeight);
            finalWidth = finalHeight * aspectRatio;
            
            // If width exceeds available width, scale down
            if (finalWidth > availableWidth) {
                finalWidth = availableWidth;
                finalHeight = finalWidth / aspectRatio;
            }
        }
        
        // Apply fixed pixel dimensions to the modal content
        // This is crucial for zoom resistance - using pixels instead of percentages
        modalContent.style.width = `${finalWidth}px`;
        modalContent.style.height = `${finalHeight}px`;
        
        // Apply dimensions to the image
        modalImg.style.maxWidth = '100%';
        modalImg.style.maxHeight = '100%';
        modalImg.style.width = 'auto';
        modalImg.style.height = 'auto';
        
        // Set the image source
        modalImg.src = url;
        
        // Make sure close button is visible and positioned correctly
        if (closeBtn) {
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '10px';
            closeBtn.style.right = '10px';
        }
        
        // Handle window resize (including zoom changes)
        const handleResize = function() {
            // Recalculate available space
            const newAvailableWidth = window.innerWidth * 0.9;
            const newAvailableHeight = window.innerHeight * 0.8;
            const newTopPadding = window.innerHeight * 0.1;
            
            // Update modal padding
            modal.style.paddingTop = `${newTopPadding}px`;
            
            // Recalculate optimal dimensions
            let newFinalWidth, newFinalHeight;
            
            if (aspectRatio > 1) { // Landscape
                newFinalWidth = Math.min(newAvailableWidth, imgWidth);
                newFinalHeight = newFinalWidth / aspectRatio;
                
                if (newFinalHeight > newAvailableHeight) {
                    newFinalHeight = newAvailableHeight;
                    newFinalWidth = newFinalHeight * aspectRatio;
                }
            } else { // Portrait
                newFinalHeight = Math.min(newAvailableHeight, imgHeight);
                newFinalWidth = newFinalHeight * aspectRatio;
                
                if (newFinalWidth > newAvailableWidth) {
                    newFinalWidth = newAvailableWidth;
                    newFinalHeight = newFinalWidth / aspectRatio;
                }
            }
            
            // Update modal content dimensions
            modalContent.style.width = `${newFinalWidth}px`;
            modalContent.style.height = `${newFinalHeight}px`;
        };
        
        // Add resize listener
        window.addEventListener('resize', handleResize);
        
        // Store the resize handler to remove it when modal closes
        modal._resizeHandler = handleResize;
    };
    
    tempImg.onerror = function() {
        // Remove loading indicator
        if (loadingIndicator.parentNode) {
            loadingIndicator.parentNode.removeChild(loadingIndicator);
        }
        
        // Handle image loading errors
        console.error("Error loading image: " + url);
        modalContent.innerHTML = `
            <div style="padding: 20px; color: var(--primary-accent); text-align: center;">
                <i class="fas fa-exclamation-triangle" style="font-size: 2em; margin-bottom: 10px;"></i>
                <p>Image could not be loaded</p>
                <button class="close-modal" onclick="closePhotoModal()">×</button>
            </div>
        `;
    };
    
    tempImg.src = url;
}

        // Updated function to restore map controls when closing modal
function closePhotoModal() {
    const modal = document.getElementById('photoModal');
    
    // Restore map controls when closing modal
    document.querySelectorAll('.leaflet-control-container').forEach(control => {
        control.style.visibility = 'visible';
    });
    
    // Restore scrolling
    document.body.style.overflow = '';
    
    // Remove resize event listener if exists
    if (modal._resizeHandler) {
        window.removeEventListener('resize', modal._resizeHandler);
        delete modal._resizeHandler;
    }
    
    modal.style.display = 'none';
    
    // Reset modal content
    const modalContent = document.querySelector('.modal-content');
    const modalImg = document.getElementById('modalImage');
    if (modalImg) {
        modalImg.src = '';
    }
}

        // Function to find the best performing stone
        async function findBestPerformingStone() {
            try {
                let bestStone = null;
                let maxJourneyCount = 0;
                let tiedStones = [];

                // First, find the maximum journey count and all stones with that count
                for (const stone of allStones) {
                    if (stone.journeyCount > maxJourneyCount) {
                        maxJourneyCount = stone.journeyCount;
                        tiedStones = [stone];
                    } else if (stone.journeyCount === maxJourneyCount) {
                        tiedStones.push(stone);
                    }
                }

                console.log(`Found ${tiedStones.length} stones with ${maxJourneyCount} journeys`);

                // If there's only one best stone, return it
                if (tiedStones.length === 1) {
                    bestStone = tiedStones[0];
                } 
                // If there are multiple stones with the same journey count, use tiebreaker
                else if (tiedStones.length > 1) {
                    bestStone = await findEarliestToReachCount(tiedStones, maxJourneyCount);
                }

                return bestStone;
            } catch (error) {
                console.error("Error finding best stone:", error);
                return null;
            }
        }

        // Function to find which stone reached the journey count first
        async function findEarliestToReachCount(stones, journeyCount) {
            try {
                let earliestStone = null;
                let earliestTimestamp = null;

                for (const stone of stones) {
                    // Get all journeys for this stone, ordered by timestamp
                    const journeysSnapshot = await db.collection('stones')
                        .doc(stone.id.toString())
                        .collection('journeys')
                        .orderBy('timestamp', 'asc')
                        .get();
                    
                    // Get the timestamp of when this stone reached the journey count
                    if (journeysSnapshot.size >= journeyCount) {
                        // The timestamp of the journey that made it reach the count
                        const journeyDoc = journeysSnapshot.docs[journeyCount - 1];
                        const timestamp = journeyDoc.data().timestamp;
                        
                        if (timestamp && (!earliestTimestamp || timestamp.toDate() < earliestTimestamp.toDate())) {
                            earliestTimestamp = timestamp;
                            earliestStone = stone;
                            console.log(`Stone ${stone.id} reached ${journeyCount} journeys at ${timestamp.toDate().toLocaleString()}`);
                        }
                    }
                }

                return earliestStone;
            } catch (error) {
                console.error("Error in tiebreaker:", error);
                return stones[0]; // Default to the first stone in case of error
            }
        }

        // Function to update the best stone display
        async function updateBestStoneDisplay(stone) {
            const bestStoneInfo = document.getElementById('bestStoneInfo');
            const bestStonePhoto = document.getElementById('bestStonePhoto');
            
            if (!stone) {
                bestStoneInfo.innerHTML = "No data";
                bestStonePhoto.innerHTML = "";
                return;
            }
            
            let photoUrl = null;
            
            // Try to get the stone's photo
            try {
                // Check Firestore for the photo URL
                const stoneDoc = await db.collection('stones').doc(stone.id.toString()).get();
                const stoneData = stoneDoc.data() || {};
                
                if (stoneData.featurePhoto && stoneData.featurePhoto.url) {
                    photoUrl = stoneData.featurePhoto.url;
                } else {
                    // If not in Firestore, try Storage directly
                    try {
                        const storageRef = storage.ref(`stones/${stone.id}/${stone.id}`);
                        photoUrl = await storageRef.getDownloadURL();
                    } catch (err) {
                        // No photo found
                        console.log(`No photo found for best stone #${stone.id}`);
                    }
                }
                
                // Create the content for stone info (left side)
                bestStoneInfo.innerHTML = `
                    <h3 style="margin: 5px 0 3px 0; font-size: 0.9em;">ID: ${stone.id}</h3>
                    <button class="view-stone-btn" onclick="selectStone('${stone.id}')">
                        SCAN
                    </button>
                `;
                
                // Create the content for stone photo (right side)
                if (photoUrl) {
                    bestStonePhoto.innerHTML = `
                        <img src="${photoUrl}" 
                             alt="Stone #${stone.id}" 
                             class="best-stone-photo"
                             onclick="openPhotoModal('${photoUrl}')"
                        >
                        <p style="margin: 3px 0 0 0; font-size: 0.75em; color: var(--text-secondary);">${stone.journeyCount} jumps</p>
                    `;
                } else {
                    bestStonePhoto.innerHTML = `
                        <div class="stone-placeholder" style="width: 70px; height: 70px;">
                            <p style="margin: 0; color: var(--text-secondary); font-size: 0.7em;">No image</p>
                        </div>
                        <p style="margin: 3px 0 0 0; font-size: 0.75em; color: var(--text-secondary);">${stone.journeyCount} jumps</p>
                    `;
                }
                
            } catch (error) {
                console.error("Error updating best stone display:", error);
                bestStoneInfo.innerHTML = `Error`;
                bestStonePhoto.innerHTML = ``;
            }
        }

        // File input handling
        function handleFileSelect(event) {
            selectedFile = event.target.files[0];
            document.getElementById('fileName').textContent = selectedFile ? selectedFile.name : '';
            document.getElementById('uploadBtn').disabled = !selectedFile;
        }

        // Modified upload stone photo function to refresh all stones map after upload
        async function uploadStonePhoto() {
            if (!selectedFile || !activeStoneId) return;
            
            showLoading();
            try {
                console.log(`Uploading photo for stone #${activeStoneId}`);
                
                // Create a reference to the file in Firebase Storage
                // Use simple naming with just the stoneID
                const storageRef = storage.ref(`stones/${activeStoneId}/${activeStoneId}`);
                
                // Upload the file
                const uploadTask = storageRef.put(selectedFile);
                
                // Listen for upload completion
                uploadTask.on('state_changed', 
                    (snapshot) => {
                        // Progress handling if needed
                        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
                        console.log('Upload is ' + progress + '% done');
                    }, 
                    (error) => {
                        // Error handling
                        console.error("Error uploading file:", error);
                        hideLoading();
                        alert("Error uploading file: " + error.message);
                    }, 
                    async () => {
                        try {
                            // Upload completed successfully
                            const downloadURL = await uploadTask.snapshot.ref.getDownloadURL();
                            console.log("File uploaded successfully. URL:", downloadURL);
                            
                            try {
                                // Store the reference in Firestore
                                await db.collection('stones').doc(activeStoneId).update({
                                    featurePhoto: {
                                        url: downloadURL,
                                        filename: selectedFile.name,
                                        uploadedAt: firebase.firestore.FieldValue.serverTimestamp()
                                    }
                                });
                                console.log("Firestore updated with new photo URL");
                            } catch (firestoreError) {
                                console.error("Firestore update error:", firestoreError);
                                // Continue even if Firestore update fails - we still have the image URL
                            }
                            
                            // Reset the file input
                            document.getElementById('fileInput').value = '';
                            document.getElementById('fileName').textContent = '';
                            document.getElementById('uploadBtn').disabled = true;
                            selectedFile = null;
                            
                            // Display the photo directly instead of reloading
                            const journeyDetails = document.getElementById('journeyDetails');
                            
                            // Find the feature photo container in the new layout
                            let featurePhotoContainer = journeyDetails.querySelector('.feature-photo-container');
                            
                            // Update the feature photo content
                            if (featurePhotoContainer) {
                                featurePhotoContainer.innerHTML = `
                                    <h3 style="font-size: 0.9em; margin-top: 0;"><i class="fas fa-camera"></i> SPECIMEN IMAGE</h3>
                                    <img src="${downloadURL}" 
                                        alt="Stone #${activeStoneId}" 
                                        class="stone-feature-image"
                                        onclick="openPhotoModal('${downloadURL}')"
                                    >
                                    <p style="margin-top: 5px; color: var(--text-secondary); font-size: 0.7em;">
                                        Just now
                                    </p>
                                `;
                            }
                            
                            // Refresh the all stones map to show the new photo
                            loadAllStonesLocations();
                            
                            hideLoading();
                            alert("✅ TRANSMISSION COMPLETE: Specimen image successfully uploaded to the quantum database!");
                            
                            // Scroll to the feature photo section
                            setTimeout(() => {
                                if (featurePhotoContainer) {
                                    featurePhotoContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            }, 100);
                            
                            // Update the stone card in the current view
                            updateStonePhotoIndicator(activeStoneId);
                            
                            // If this stone is the best performer, update its display
                            const bestStoneInfo = document.getElementById('bestStoneInfo');
                            if (bestStoneInfo && bestStoneInfo.innerHTML.includes(`ID: ${activeStoneId}`)) {
                                // Re-find the best stone to update its display
                                const bestStone = await findBestPerformingStone();
                                if (bestStone) {
                                    await updateBestStoneDisplay(bestStone);
                                }
                            }
                            
                        } catch (error) {
                            console.error("Error processing upload completion:", error);
                            hideLoading();
                            alert("⚠️ PARTIAL SUCCESS: Image data stored in quantum database, but display matrix failed to render. Initiate system refresh protocol.");
                        }
                    }
                );
            } catch (error) {
                console.error("Error in upload process:", error);
                hideLoading();
                alert("Error in upload process: " + error.message);
            }
        }

        // Update photo indicator on stone card after upload
        function updateStonePhotoIndicator(stoneId) {
            // Find the stone card
            const stoneCard = document.querySelector(`.stone-card[data-stone-id="${stoneId}"]`);
            if (stoneCard) {
                // Check if photo indicator already exists
                if (!stoneCard.querySelector('.photo-indicator')) {
                    // Add photo indicator
                    const photoIndicator = document.createElement('div');
                    photoIndicator.className = 'photo-indicator';
                    photoIndicator.style.color = 'var(--primary-accent)';
                    photoIndicator.style.marginTop = '2px';
                    photoIndicator.innerHTML = '<i class="fas fa-camera"></i>';
                    stoneCard.insertBefore(photoIndicator, stoneCard.querySelector('p'));
                }
            }
        }

        // Load recent updates across all stones
        async function loadRecentUpdates() {
            const recentUpdates = document.getElementById('recentUpdates');
            recentUpdates.innerHTML = '';
            showLoading();

            try {
                const stonesSnapshot = await db.collection('stones').get();
                let allUpdates = [];

                for (const stoneDoc of stonesSnapshot.docs) {
                    const journeysSnapshot = await stoneDoc.ref.collection('journeys')
                        .orderBy('timestamp', 'desc')
                        .limit(5)
                        .get();

                    journeysSnapshot.docs.forEach(doc => {
                        const data = doc.data();
                        allUpdates.push({
                            stoneId: stoneDoc.id,
                            ...data
                        });
                    });
                }

                allUpdates.sort((a, b) => b.timestamp - a.timestamp);

                allUpdates.slice(0, 20).forEach(update => {
                    const date = update.timestamp ? update.timestamp.toDate().toLocaleDateString() : 'Recent';
                    const time = update.timestamp ? update.timestamp.toDate().toLocaleTimeString() : '';
                    
                    const entry = document.createElement('div');
                    entry.className = 'update-entry';
                    
                    let photoHtml = '';
                    if (update.photoData && update.photoData.url) {
                        photoHtml = `
                            <img src="${update.photoData.url}" 
                                alt="Stone photo" 
                                class="update-photo"
                                onclick="openPhotoModal('${update.photoData.url}')"
                                loading="lazy"
                            >
                        `;
                    }

                    entry.innerHTML = `
                        <div class="update-content">
                            <h3><i class="fas fa-broadcast-tower"></i> SPECIMEN ${update.stoneId}</h3>
                            <p>${update.message}</p>
                            <p class="timestamp"><i class="fas fa-clock"></i> ${date} <i class="fas fa-calendar-alt" style="margin-left: 10px;"></i> ${time}</p>
                            ${photoHtml}
                        </div>
                    `;
                    recentUpdates.appendChild(entry);
                });

            } catch (error) {
                console.error("Error loading recent updates:", error);
            } finally {
                hideLoading();
            }
        }

        // Create stone card - sci-fi style with improved text handling
        async function createStoneCard(doc, journeyCount, hasPhoto) {
            // Create stone card
            const card = document.createElement('div');
            card.className = 'stone-card';
            card.dataset.stoneId = doc.id;
            
            // Add photo indicator if there's a photo with an icon
            card.innerHTML = `
                <h3><span style="color: var(--primary-accent);">#</span>${doc.id}</h3>
                ${hasPhoto ? '<div style="color: var(--primary-accent); margin-top: 2px;"><i class="fas fa-camera"></i></div>' : ''}
                <p><i class="fas fa-route" style="color: var(--primary-accent); font-size: 0.8em;"></i> ${journeyCount} jumps</p>
            `;
            
            card.onclick = () => selectStone(doc.id);
            
            return card;
        }

        // Modified: Load stone card info
        async function loadStoneCardInfo(doc) {
            try {
                // Debug log
                console.log(`Loading stone card for ID: ${doc.id}`);
                
                const journeysSnapshot = await doc.ref.collection('journeys')
                    .orderBy('timestamp', 'desc')
                    .get();
                
                const journeyCount = journeysSnapshot.size;
                console.log(`Stone ${doc.id} has ${journeyCount} journeys`);
                
                // Get stone data to check for feature photo
                const stoneData = doc.data() || {};
                
                // Check if this stone has a feature photo
                let hasPhoto = stoneData.featurePhoto && stoneData.featurePhoto.url;
                let photoUrl = hasPhoto ? stoneData.featurePhoto.url : null;
                
                // If no photo in Firestore, check Storage directly
                if (!hasPhoto) {
                    try {
                        const storageRef = storage.ref(`stones/${doc.id}/${doc.id}`);
                        photoUrl = await storageRef.getDownloadURL();
                        hasPhoto = true;
                        console.log(`Found photo for stone ${doc.id} in Storage`);
                    } catch (err) {
                        // No photo in Storage either
                        hasPhoto = false;
                        console.log(`No photo found for stone ${doc.id}`);
                    }
                } else {
                    console.log(`Found photo for stone ${doc.id} in Firestore`);
                }
                
                // Create card
                const card = await createStoneCard(doc, journeyCount, hasPhoto);
                
                // Return all the information
                return { 
                    id: doc.id,
                    card: card, 
                    journeyCount: journeyCount,
                    hasPhoto: hasPhoto,
                    photoUrl: photoUrl
                };
            } catch (error) {
                console.error(`Error loading stone card ${doc.id}:`, error);
                return { id: doc.id, card: null, journeyCount: 0, hasPhoto: false, photoUrl: null };
            }
        }

        // Create folders based on stone grouping - with separate text lines for "Stones" and range numbers
        function createFolders(stones) {
            // Group stones into folders (1-8, 9-16, 17-24, etc.)
            const folderGroups = {};
            
            // Debug
            console.log(`Creating folders for ${stones.length} stones`);
            
            stones.forEach(stone => {
                // Extract the numeric part from the stone ID
                // This handles both numeric IDs and IDs with prefixes like "stone1"
                const stoneIdStr = stone.id.toString();
                const numericPart = stoneIdStr.replace(/\D/g, '');
                const stoneNum = parseInt(numericPart);
                
                if (isNaN(stoneNum)) {
                    console.warn(`Could not parse numeric ID from stone: ${stoneIdStr}`);
                    return; // Skip this stone
                }
                
                // Calculate folder bounds
                const folderIndex = Math.floor((stoneNum - 1) / 8);
                const minStoneInFolder = folderIndex * 8 + 1;
                const maxStoneInFolder = (folderIndex + 1) * 8;
                const folderId = `${minStoneInFolder}-${maxStoneInFolder}`;
                
                if (!folderGroups[folderId]) {
                    folderGroups[folderId] = [];
                }
                
                folderGroups[folderId].push(stone);
                console.log(`Added stone ${stoneIdStr} (numeric: ${stoneNum}) to folder ${folderId}`);
            });
            
            // Create folder cards
            const foldersGrid = document.getElementById('foldersGrid');
            foldersGrid.innerHTML = '';
            
            // Sort folder IDs numerically
            const sortedFolderIds = Object.keys(folderGroups).sort((a, b) => {
                const [minA] = a.split('-').map(Number);
                const [minB] = b.split('-').map(Number);
                return minA - minB;
            });
            
            console.log(`Created ${sortedFolderIds.length} folders: ${sortedFolderIds.join(', ')}`);
            
            sortedFolderIds.forEach(folderId => {
                const stones = folderGroups[folderId];
                const [minStone, maxStone] = folderId.split('-');
                const folderName = `Stones ${minStone}-${maxStone}`;
                
                // Count stones with photos
                const stonesWithPhotos = stones.filter(stone => stone.hasPhoto).length;
                
                const folderCard = document.createElement('div');
                folderCard.className = 'folder-card';
                folderCard.dataset.folderId = folderId;
                
                // Modified HTML to have "Stones" and range numbers on separate lines
                folderCard.innerHTML = `
                    <div class="folder-icon"><i class="fas fa-layer-group"></i></div>
                    <h3>
                        <span class="folder-label">Stones</span>
                        <span class="folder-range">${minStone}-${maxStone}</span>
                    </h3>
                    <p>${stones.length} specimens</p>
                `;
                
                folderCard.onclick = () => showStonesInFolder(folderId, folderName);
                foldersGrid.appendChild(folderCard);
            });
        }

        // Modified: Load all stones with proper ordering
        async function loadStones() {
            showLoading();
            try {
                const snapshot = await db.collection('stones').get();
                
                console.log(`Loaded ${snapshot.size} stones from Firestore`);
                
                // Debug: Log all stone IDs
                console.log("Stone IDs from Firestore:", snapshot.docs.map(doc => doc.id));
                
                let totalJourneys = 0;
                let activeThisMonth = 0;
                const currentMonth = new Date().getMonth();
                
                // Handle both numeric IDs and string IDs that might contain "stone" prefix
                const sortedDocs = [...snapshot.docs].sort((a, b) => {
                    // Extract numeric parts from IDs (removing any non-digit characters)
                    const numA = parseInt(a.id.toString().replace(/\D/g, ''));
                    const numB = parseInt(b.id.toString().replace(/\D/g, ''));
                    
                    if (!isNaN(numA) && !isNaN(numB)) {
                        return numA - numB; // Numeric sorting
                    } else {
                        return a.id.localeCompare(b.id); // String sorting as fallback
                    }
                });
                
                // Create an array of promises for loading each stone card
                const loadPromises = sortedDocs.map(doc => loadStoneCardInfo(doc));
                
                // Wait for all stone cards to be loaded
                const results = await Promise.all(loadPromises);
                
                // Filter out any null results
                allStones = results.filter(result => result.card !== null);
                
                console.log(`Successfully loaded ${allStones.length} stone cards`);
                
                // Calculate total journeys
                totalJourneys = allStones.reduce((total, stone) => total + stone.journeyCount, 0);
                
                // Check which stones are active this month
                for (let i = 0; i < sortedDocs.length; i++) {
                    const doc = sortedDocs[i];
                    const lastJourneySnapshot = await doc.ref.collection('journeys')
                        .orderBy('timestamp', 'desc')
                        .limit(1)
                        .get();
                        
                    if (!lastJourneySnapshot.empty) {
                        const data = lastJourneySnapshot.docs[0].data();
                        if (data.timestamp && data.timestamp.toDate().getMonth() === currentMonth) {
                            activeThisMonth++;
                        }
                    }
                }

                // Update stats
                document.getElementById('totalStones').textContent = snapshot.size;
                document.getElementById('totalJourneys').textContent = totalJourneys;
                document.getElementById('activeStones').textContent = activeThisMonth;
                
                // Create folders based on stone grouping
                createFolders(allStones);
                
                // Find and display the best performing stone
                const bestStone = await findBestPerformingStone();
                if (bestStone) {
                    console.log(`Best performing stone: #${bestStone.id} with ${bestStone.journeyCount} journeys`);
                    await updateBestStoneDisplay(bestStone);
                } else {
                    console.log("Could not determine best performing stone");
                }
                
                // Initialize gallery AFTER folders are created
                initializeGallery();

            } catch (error) {
                console.error("Error loading stones:", error);
            } finally {
                hideLoading();
            }
        }

        function initMap() {
            // Initialize journey map
            if (currentMap) {
                currentMap.remove();
            }

            currentMap = L.map('journeyMap').setView([0, 0], 2);
            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '© OpenStreetMap'
            }).addTo(currentMap);

            // Add a scale control to the map
            L.control.scale().addTo(currentMap);
            
            // Initialize all stones map if it doesn't exist
            if (!allStonesMap) {
                initializeAllStonesMap();
            }
        }
        
        function initializeAllStonesMap() {
            if (allStonesMap) {
                allStonesMap.remove();
            }
            
            allStonesMap = L.map('allStonesMap').setView([0, 0], 2);
            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '© OpenStreetMap'
            }).addTo(allStonesMap);
            
            // Add a scale control to the map
            L.control.scale().addTo(allStonesMap);
            
            // Load all stones' most recent locations
            loadAllStonesLocations();
        }
        
        async function loadAllStonesLocations() {
            showLoading();
            
            try {
                // Clear existing markers
                if (allStonesMarkers.length > 0) {
                    allStonesMarkers.forEach(marker => {
                        allStonesMap.removeLayer(marker);
                    });
                }
                allStonesMarkers = [];
                
                const stones = await db.collection('stones').get();
                
                const bounds = L.latLngBounds();
                const locationPromises = [];
                
                for (const stoneDoc of stones.docs) {
                    const stoneId = stoneDoc.id;
                    
                    // Get the most recent journey for this stone
                    const journey = await stoneDoc.ref.collection('journeys')
                        .orderBy('timestamp', 'desc')
                        .limit(1)
                        .get();
                    
                    if (!journey.empty) {
                        const journeyData = journey.docs[0].data();
                        
                        // Get coordinates
                        let coords = journeyData.coordinates;
                        if (!coords && journeyData.location) {
                            coords = await getCoordinates(journeyData.location);
                        }
                        
                        if (coords) {
                            // Get stone feature photo if available
                            let photoUrl = null;
                            const stoneData = stoneDoc.data();
                            
                            if (stoneData.featurePhoto && stoneData.featurePhoto.url) {
                                photoUrl = stoneData.featurePhoto.url;
                            } else {
                                // Try to get from storage
                                try {
                                    const storageRef = storage.ref(`stones/${stoneId}/${stoneId}`);
                                    photoUrl = await storageRef.getDownloadURL();
                                } catch (err) {
                                    // No photo available
                                }
                            }
                            
                            // Prepare popup content - PHOTO ONLY
                            let popupContent = `
                                <div style="text-align: center;">
                            `;
                            
                            // Check if stone has a photo
                            if (photoUrl) {
                                popupContent += `
                                    <img src="${photoUrl}" 
                                        style="width: 60px; height: 60px; object-fit: cover; border-radius: 50%; cursor: pointer; background: rgba(15, 22, 49, 0.7); filter: drop-shadow(0 0 10px rgba(0, 229, 255, 0.3)); border: 2px solid var(--primary-accent);"
                                        onclick="selectStone('${stoneId}'); setTimeout(() => { document.getElementById('journeyDetails').scrollIntoView({behavior: 'smooth'}); }, 300);"
                                    >
                                `;
                            } else if (journeyData.photoData && journeyData.photoData.url) {
                                // If no stone photo, use the most recent journey photo
                                popupContent += `
                                    <img src="${journeyData.photoData.url}" 
                                        style="width: 60px; height: 60px; object-fit: cover; border-radius: 50%; cursor: pointer; background: rgba(15, 22, 49, 0.7); filter: drop-shadow(0 0 10px rgba(0, 229, 255, 0.3)); border: 2px solid var(--secondary-accent);"
                                        onclick="selectStone('${stoneId}'); setTimeout(() => { document.getElementById('journeyDetails').scrollIntoView({behavior: 'smooth'}); }, 300);"
                                    >
                                `;
                            } else {
                                // No photos available at all
                                popupContent += `
                                    <div style="width: 60px; height: 60px; border-radius: 50%; background: rgba(15, 22, 49, 0.7); display: flex; align-items: center; justify-content: center; font-size: 0.7em; color: var(--text-secondary); border: 2px solid var(--primary-accent); text-align: center; cursor: pointer;"
                                         onclick="selectStone('${stoneId}'); setTimeout(() => { document.getElementById('journeyDetails').scrollIntoView({behavior: 'smooth'}); }, 300);">
                                        No image<br>available
                                    </div>
                                `;
                            }
                            
                            popupContent += '</div>';
                            
                            // Create marker with custom icon - sci-fi style
                            const markerIcon = L.divIcon({
                                html: `<div style="width: 14px; height: 14px; background-color: var(--primary-accent); border-radius: 50%; box-shadow: 0 0 10px var(--primary-accent), 0 0 20px var(--primary-accent);"></div>`,
                                className: 'custom-marker',
                                iconSize: [14, 14],
                                iconAnchor: [7, 7]
                            });
                            
                            const marker = L.marker([coords.lat, coords.lon], {
                                icon: markerIcon,
                                title: `Specimen ${stoneId}`
                            }).addTo(allStonesMap).bindPopup(popupContent);
                            
                            allStonesMarkers.push(marker);
                            bounds.extend([coords.lat, coords.lon]);
                        }
                    }
                }
                
                // Fit the map to show all markers if there are any
                if (bounds.isValid()) {
                    allStonesMap.fitBounds(bounds, { padding: [30, 30] });
                }
                
            } catch (error) {
                console.error("Error loading all stones locations:", error);
            } finally {
                hideLoading();
            }
        }

        // Modified: Update stone selection function with collapsible timeline
        async function selectStone(stoneId) {
            showLoading();
            activeStoneId = stoneId;
            
            console.log(`Selecting stone #${stoneId}`);
            
            document.querySelectorAll('.stone-card').forEach(card => {
                card.classList.remove('active');
                if (card.dataset.stoneId === stoneId) {
                    card.classList.add('active');
                }
            });

            initMap();

            try {
                // Fetch stone document to get feature photo
                const stoneDoc = await db.collection('stones').doc(stoneId).get();
                const stoneData = stoneDoc.data() || {};
                
                // Clear journey details and set title
                const journeyDetails = document.getElementById('journeyDetails');
                journeyDetails.innerHTML = `<h2>SPECIMEN ${stoneId} TRAJECTORY ANALYSIS</h2>`;
                
                // Create a flex container for admin section and feature photo
                const flexContainer = document.createElement('div');
                flexContainer.style.display = 'flex';
                flexContainer.style.gap = '20px';
                flexContainer.style.marginBottom = '20px';
                flexContainer.style.justifyContent = 'center';
                journeyDetails.appendChild(flexContainer);
                
                // Add admin upload section - sci-fi style
                const uploadSection = document.createElement('div');
                uploadSection.className = 'admin-upload-section';
                uploadSection.style.flex = '0 0 170px'; // Match the photo container width
                uploadSection.style.minHeight = '220px';
                uploadSection.style.padding = '10px';
                uploadSection.style.display = 'flex';
                uploadSection.style.flexDirection = 'column';
                uploadSection.innerHTML = `
                    <h3 style="font-size: 0.9em; margin-top: 0;"><i class="fas fa-upload"></i> UPLOAD IMAGE</h3>
                    <div class="file-input-container" style="flex-grow: 1; display: flex; flex-direction: column; justify-content: center;">
                        <label for="fileInput" class="custom-file-upload">
                            <i class="fas fa-file-image"></i> SELECT FILE
                        </label>
                        <input type="file" id="fileInput" accept="image/*" onchange="handleFileSelect(event)">
                        <div id="fileName" class="file-name"></div>
                        <button id="uploadBtn" class="upload-btn" onclick="uploadStonePhoto()" disabled>
                            <i class="fas fa-satellite-dish"></i> TRANSMIT
                        </button>
                    </div>
                `;
                flexContainer.appendChild(uploadSection);
                
                // Try to get photo URL - first from Firestore, then from Storage
                let photoUrl = null;
                let uploadDate = 'Recently';
                
                // Check if the stone has a feature photo in Firestore
                if (stoneData.featurePhoto && stoneData.featurePhoto.url) {
                    photoUrl = stoneData.featurePhoto.url;
                    if (stoneData.featurePhoto.uploadedAt) {
                        const date = stoneData.featurePhoto.uploadedAt.toDate();
                        uploadDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                    }
                } else {
                    // If not in Firestore, try to get directly from Storage
                    try {
                        console.log("Checking Storage for photo: ", `stones/${stoneId}/${stoneId}`);
                        const storageRef = storage.ref(`stones/${stoneId}/${stoneId}`);
                        photoUrl = await storageRef.getDownloadURL();
                        console.log("Found photo directly in Storage:", photoUrl);
                        
                        // Update Firestore with the photo URL for future reference
                        try {
                            await db.collection('stones').doc(stoneId).update({
                                featurePhoto: {
                                    url: photoUrl,
                                    uploadedAt: firebase.firestore.FieldValue.serverTimestamp()
                                }
                            });
                            console.log("Updated Firestore with Storage photo URL");
                        } catch (updateError) {
                            console.error("Error updating Firestore with photo URL:", updateError);
                        }
                    } catch (storageError) {
                        console.log("No feature photo found in Storage:", storageError);
                    }
                }
                
                // Create feature photo container (displayed or empty) - sci-fi style
                const featurePhotoContainer = document.createElement('div');
                featurePhotoContainer.className = 'admin-upload-section feature-photo-container';
                featurePhotoContainer.style.flex = '0 0 170px'; // Fixed width for the thumbnail container
                featurePhotoContainer.style.minHeight = '220px';
                featurePhotoContainer.style.textAlign = 'center';
                featurePhotoContainer.style.display = 'flex';
                featurePhotoContainer.style.flexDirection = 'column';
                featurePhotoContainer.style.justifyContent = 'center';
                featurePhotoContainer.style.padding = '10px';
                
                // Display feature photo if it exists
                if (photoUrl) {
                    console.log("Displaying photo:", photoUrl);
                    featurePhotoContainer.innerHTML = `
                        <h3 style="font-size: 0.9em; margin-top: 0;"><i class="fas fa-camera"></i> SPECIMEN IMAGE</h3>
                        <img src="${photoUrl}" 
                            alt="Stone #${stoneId}" 
                            class="stone-feature-image"
                            onclick="openPhotoModal('${photoUrl}')"
                        >
                        <p style="margin-top: 5px; color: var(--text-secondary); font-size: 0.7em;">
                            ${uploadDate}
                        </p>
                    `;
                } else {
                    featurePhotoContainer.innerHTML = `
                        <h3 style="font-size: 0.9em; margin-top: 0;"><i class="fas fa-camera"></i> SPECIMEN IMAGE</h3>
                        <div class="stone-placeholder">
                            <p style="color: var(--text-secondary); margin: 0; font-size: 0.8em;">No image detected</p>
                        </div>
                    `;
                    console.log("No photo found for this stone");
                }
                
                // Add the feature photo container to the flex container
                flexContainer.appendChild(featurePhotoContainer);

                const journeysSnapshot = await db.collection('stones')
                    .doc(stoneId)
                    .collection('journeys')
                    .orderBy('timestamp', 'desc')
                    .get();

                const coordinates = [];
                const bounds = L.latLngBounds();

                const orderedDocs = [...journeysSnapshot.docs].reverse();
                
                // Store data for each journey point to use when creating markers
                const journeyPoints = [];
                
                // First collect all coordinates and data
                for (const doc of orderedDocs) {
                    const data = doc.data();
                    
                    let coords = data.coordinates;
                    if (!coords && data.location) {
                        coords = await getCoordinates(data.location);
                    }

                    if (coords) {
                        coordinates.push([coords.lat, coords.lon]);
                        bounds.extend([coords.lat, coords.lon]);
                        
                        // Store the journey data along with coordinates
                        journeyPoints.push({
                            coordinates: [coords.lat, coords.lon],
                            data: data,
                            stonePhotoUrl: photoUrl // Pass the stone's photo URL
                        });
                    }
                }

                // Add a journey summary section with basic stats - sci-fi style
                const journeyCount = journeysSnapshot.size;
                const firstJourneyDate = journeysSnapshot.docs.length > 0 && journeysSnapshot.docs[journeysSnapshot.docs.length - 1].data().timestamp ?
                    journeysSnapshot.docs[journeysSnapshot.docs.length - 1].data().timestamp.toDate().toLocaleDateString() : 'Unknown';
                const lastJourneyDate = journeysSnapshot.docs.length > 0 && journeysSnapshot.docs[0].data().timestamp ?
                    journeysSnapshot.docs[0].data().timestamp.toDate().toLocaleDateString() : 'Unknown';
                
                const journeySummary = document.createElement('div');
                journeySummary.className = 'journey-summary';
                journeySummary.innerHTML = `
                    <div class="journey-summary-info">
                        <h3><i class="fas fa-project-diagram"></i> QUANTUM TRAJECTORY DATA</h3>
                        <p><span style="color: var(--primary-accent);">TOTAL JUMPS:</span> ${journeyCount}</p>
                        <p><span style="color: var(--primary-accent);">ORIGIN POINT:</span> ${firstJourneyDate}</p>
                        <p><span style="color: var(--primary-accent);">CURRENT LOCATION:</span> ${lastJourneyDate}</p>
                    </div>
                `;
                journeyDetails.appendChild(journeySummary);

                if (coordinates.length > 0) {
                    // Create the main journey path polyline - sci-fi style
                    const path = L.polyline(coordinates, {
                        color: 'var(--primary-accent)',
                        weight: 3,
                        opacity: 0.7,
                        lineCap: 'round',
                        lineJoin: 'round',
                        dashArray: '8, 12',
                        className: 'journey-path-line'
                    }).addTo(currentMap);
                    
                    // Add glow effect with a duplicate line
                    const glowPath = L.polyline(coordinates, {
                        color: 'var(--primary-accent)',
                        weight: 8,
                        opacity: 0.3,
                        lineCap: 'round',
                        lineJoin: 'round',
                        className: 'journey-path-glow'
                    }).addTo(currentMap);

                    // Add numbered markers for each location
                    journeyPoints.forEach((point, index) => {
                        const isFinalPoint = index === journeyPoints.length - 1;
                        const data = point.data;
                        
                        // Create popup content - PHOTO WITH FALLBACK
                        let popupContent = `
                            <div style="text-align: center;">
                        `;
                        
                        // First try to use journey photo
                        if (data.photoData && data.photoData.url) {
                            popupContent += `
                                <img src="${data.photoData.url}" 
                                    style="width: 60px; height: 60px; object-fit: cover; border-radius: 50%; cursor: pointer; background: rgba(15, 22, 49, 0.7); filter: drop-shadow(0 0 10px rgba(0, 229, 255, 0.3)); border: 2px solid var(--primary-accent);"
                                    onclick="openPhotoModal('${data.photoData.url}')"
                                >
                            `;
                        } 
                        // Then try to use stone photo if available
                        else if (point.stonePhotoUrl) {
                            popupContent += `
                                <img src="${point.stonePhotoUrl}" 
                                    style="width: 60px; height: 60px; object-fit: cover; border-radius: 50%; cursor: pointer; background: rgba(15, 22, 49, 0.7); filter: drop-shadow(0 0 10px rgba(0, 229, 255, 0.3)); border: 2px solid var(--secondary-accent);"
                                    onclick="openPhotoModal('${point.stonePhotoUrl}')"
                                >
                            `;
                        } 
                        // No photos available
                        else {
                            popupContent += `
                                <div style="width: 60px; height: 60px; border-radius: 50%; background: rgba(15, 22, 49, 0.7); display: flex; align-items: center; justify-content: center; font-size: 0.7em; color: var(--text-secondary); border: 2px solid var(--primary-accent); text-align: center;">
                                    No image<br>available
                                </div>
                            `;
                        }
                        
                        popupContent += '</div>';
                        
                        // Create a numbered marker
                        const markerIcon = L.divIcon({
                            html: `<div class="journey-marker${isFinalPoint ? ' journey-marker-final' : ''}">${index + 1}</div>`,
                            className: 'journey-marker-container',
                            iconSize: [28, 28],
                            iconAnchor: [14, 14]
                        });
                        
                        // Add the marker with popup
                        L.marker(point.coordinates, {
                            icon: markerIcon
                        }).bindPopup(popupContent).addTo(currentMap);
                    });

                    currentMap.fitBounds(bounds, { padding: [50, 50] });
                    
                    // Highlight this stone on the all stones map
                    highlightStoneOnAllStonesMap(stoneId);
                }

                // Add the toggle button for the timeline - sci-fi style
                const toggleButton = document.createElement('button');
                toggleButton.id = 'toggleTimelineBtn';
                toggleButton.className = 'toggle-timeline-btn';
                toggleButton.innerHTML = '<i class="fas fa-clock"></i> SHOW TEMPORAL DATA <span class="arrow">▼</span>';
                toggleButton.onclick = toggleTimeline;
                journeyDetails.appendChild(toggleButton);

                // Create collapsible container for timeline entries
                const entriesContainer = document.createElement('div');
                entriesContainer.id = 'journeyEntriesContainer';
                entriesContainer.className = 'journey-entries-container journey-entries-collapsed';
                journeyDetails.appendChild(entriesContainer);

                // Add journey entries to the collapsible container - sci-fi style
                journeysSnapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const date = data.timestamp ? data.timestamp.toDate().toLocaleDateString() : 'Recent';
                    const time = data.timestamp ? data.timestamp.toDate().toLocaleTimeString() : '';
                    
                    let photoHtml = '';
                    if (data.photoData && data.photoData.url) {
                        photoHtml = `
                            <img src="${data.photoData.url}" 
                                alt="Stone location" 
                                class="journey-photo"
                                onclick="openPhotoModal('${data.photoData.url}')"
                                loading="lazy"
                            >
                        `;
                    }

                    const entry = document.createElement('div');
                    entry.className = 'journey-entry';
                    entry.innerHTML = `
                        <h3><i class="fas fa-map-marker-alt"></i> ${data.location}</h3>
                        ${photoHtml}
                        <p>${data.message}</p>
                        <p style="color: var(--text-secondary); font-size: 0.9em;"><i class="fas fa-calendar-alt"></i> ${date} <i class="fas fa-clock" style="margin-left: 10px;"></i> ${time}</p>
                    `;
                    entriesContainer.appendChild(entry);
                });

            } catch (error) {
                console.error("Error loading stone journeys:", error);
            } finally {
                hideLoading();
            }
        }
        
        // Function to highlight the selected stone on the all stones map
        function highlightStoneOnAllStonesMap(stoneId) {
            // Find the marker for this stone and open its popup
            allStonesMarkers.forEach(marker => {
                const title = marker.options.title;
                if (title === `Specimen ${stoneId}`) {
                    // Center the map on this marker and open popup
                    allStonesMap.setView(marker.getLatLng(), 12);
                    marker.openPopup();
                }
            });
        }

        // Statistics Functions
        async function loadStatistics() {
            showLoading();
            
            try {
                // Calculate and display key statistics
                await calculateKeyStats();
                
                // Create top performers chart
                await createTopPerformersChart();
                
            } catch (error) {
                console.error("Error loading statistics:", error);
            } finally {
                hideLoading();
            }
        }
        
        async function calculateKeyStats() {
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = '';
            
            try {
                // 1. Total distance traveled by all stones (estimated)
                // We'll use journey count as a proxy for distance
                const totalJourneys = allStones.reduce((total, stone) => total + stone.journeyCount, 0);
                const avgDistance = 5; // Assume average of 5km between handoffs
                const totalDistance = totalJourneys * avgDistance;
                
                // 2. Average journeys per stone
                const avgJourneys = totalJourneys / allStones.length;
                
                // 3. Most active month
                const monthCounts = await calculateMonthActivity();
                const mostActiveMonth = Object.entries(monthCounts)
                    .sort((a, b) => b[1] - a[1])[0];
                
                const monthNames = [
                    'January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'
                ];
                
                // 4. Percentage of stones with photos
                const stonesWithPhotos = allStones.filter(stone => stone.hasPhoto).length;
                const photoPercentage = Math.round((stonesWithPhotos / allStones.length) * 100);
                
                // 5. Average journey chain length (consecutive handoffs)
                // For this we'll use a simplified estimate
                let maxConsecutiveDays = 0;
                
                // 6. Unique locations estimate
                // We'll use a random number based on journey count as a placeholder
                // In a real implementation, you'd count actual unique locations from journey data
                const uniqueLocationsEstimate = Math.min(
                    Math.round(totalJourneys * 0.7),
                    totalJourneys
                );
                
                // Create stat boxes
                const statBoxes = [
                    {
                        title: "Total Distance Traveled",
                        value: `${totalDistance}km`,
                        subtitle: "Estimated spatial displacement"
                    },
                    {
                        title: "Avg Jumps Per Stone",
                        value: avgJourneys.toFixed(1),
                        subtitle: "Quantum transit frequency"
                    },
                    {
                        title: "Most Active Month",
                        value: monthNames[parseInt(mostActiveMonth[0])],
                        subtitle: `${mostActiveMonth[1]} quantum jumps`
                    },
                    {
                        title: "Specimens With Images",
                        value: `${photoPercentage}%`,
                        subtitle: `${stonesWithPhotos} of ${allStones.length} specimens`
                    },
                    {
                        title: "Unique Locations",
                        value: uniqueLocationsEstimate,
                        subtitle: "Estimated spatial coordinates"
                    },
                    {
                        title: "Prime Specimen",
                        value: `#${await getMostActiveStone()}`,
                        subtitle: "Highest quantum activity"
                    }
                ];
                
                // Add stat boxes to the grid
                statBoxes.forEach(stat => {
                    const statBox = document.createElement('div');
                    statBox.className = 'stat-box';
                    statBox.innerHTML = `
                        <h3>${stat.title}</h3>
                        <p class="value">${stat.value}</p>
                        <p class="subtitle">${stat.subtitle}</p>
                    `;
                    statsGrid.appendChild(statBox);
                });
                
            } catch (error) {
                console.error("Error calculating statistics:", error);
                statsGrid.innerHTML = '<p>Error loading statistics</p>';
            }
        }
        
        async function getMostActiveStone() {
            // Sort stones by journey count and return the ID of the one with most journeys
            const sortedStones = [...allStones].sort((a, b) => b.journeyCount - a.journeyCount);
            return sortedStones.length > 0 ? sortedStones[0].id : 'N/A';
        }
        
        async function calculateMonthActivity() {
            // Initialize month counts
            const monthCounts = {};
            for (let i = 0; i < 12; i++) {
                monthCounts[i] = 0;
            }
            
            // Count journeys per month
            for (const stone of allStones) {
                try {
                    const journeys = await db.collection('stones')
                        .doc(stone.id.toString())
                        .collection('journeys')
                        .get();
                    
                    journeys.docs.forEach(doc => {
                        const data = doc.data();
                        if (data.timestamp) {
                            const month = data.timestamp.toDate().getMonth();
                            monthCounts[month] = (monthCounts[month] || 0) + 1;
                        }
                    });
                } catch (error) {
                    console.error(`Error getting journeys for stone ${stone.id}:`, error);
                }
            }
            
            return monthCounts;
        }
        
        // Function to create top performers chart - sci-fi style
        async function createTopPerformersChart() {
            try {
                // Get top 3 stones by journey count
                const top3Stones = [...allStones]
                    .sort((a, b) => b.journeyCount - a.journeyCount)
                    .slice(0, 3);
                
                console.log("Top 3 stones:", top3Stones);
                
                if (top3Stones.length === 0) {
                    document.getElementById('topPerformersChart').innerHTML = 
                        '<p style="text-align: center; padding: 40px; color: var(--text-secondary);"><i class="fas fa-database" style="font-size: 2em; color: var(--primary-accent); margin-bottom: 15px; display: block;"></i>NO SPECIMEN DATA AVAILABLE FOR ANALYSIS</p>';
                    return;
                }
                
                // Prepare chart data
                const chartData = top3Stones.map(stone => ({
                    name: `#${stone.id}`,
                    journeys: stone.journeyCount,
                    photoUrl: stone.photoUrl,
                    stoneId: stone.id
                }));
                
                // Get photo URLs if not already fetched
                for (let i = 0; i < chartData.length; i++) {
                    if (!chartData[i].photoUrl) {
                        try {
                            const stoneDoc = await db.collection('stones').doc(chartData[i].stoneId.toString()).get();
                            const stoneData = stoneDoc.data() || {};
                            
                            if (stoneData.featurePhoto && stoneData.featurePhoto.url) {
                                chartData[i].photoUrl = stoneData.featurePhoto.url;
                            } else {
                                // Try Storage
                                try {
                                    const storageRef = storage.ref(`stones/${chartData[i].stoneId}/${chartData[i].stoneId}`);
                                    chartData[i].photoUrl = await storageRef.getDownloadURL();
                                } catch (err) {
                                    // No photo available
                                    chartData[i].photoUrl = null;
                                }
                            }
                        } catch (error) {
                            console.error(`Error getting photo for stone ${chartData[i].stoneId}:`, error);
                        }
                    }
                }
                
                // Create the chart with HTML/CSS - sci-fi style
                const chartContainer = document.getElementById('topPerformersChart');
                
                // Find max journeys for scaling
                let maxJourneys = Math.max(...chartData.map(item => item.journeys));
                maxJourneys = Math.ceil(maxJourneys * 1.2); // Add some space at the top
                
                // Calculate bar heights
                chartData.forEach(item => {
                    item.heightPercentage = (item.journeys / maxJourneys) * 100;
                });
                
                // Create a responsive chart with HTML and CSS
                let chartHTML = `
                    <div style="position: relative; width: 100%; height: 100%; padding-top: 20px; margin-bottom: 30px;">
                        <div style="position: absolute; left: 0; top: 0; bottom: 50px; width: 50px; border-right: 1px solid var(--primary-accent); opacity: 0.5;">
                            <!-- Y-axis labels -->
                            <div style="position: absolute; top: 0; right: 5px; text-align: right; color: var(--primary-accent); font-family: 'Orbitron', sans-serif;">${maxJourneys}</div>
                            <div style="position: absolute; top: 50%; right: 5px; text-align: right; color: var(--primary-accent); font-family: 'Orbitron', sans-serif;">${Math.round(maxJourneys/2)}</div>
                            <div style="position: absolute; bottom: 0; right: 5px; text-align: right; color: var(--primary-accent); font-family: 'Orbitron', sans-serif;">0</div>
                        </div>
                        <div style="position: absolute; left: 50px; right: 0; top: 0; bottom: 50px;">
                            <!-- Chart area -->
                            <div style="position: relative; width: 100%; height: 100%;">
                                <!-- Grid lines - sci-fi style -->
                                <div style="position: absolute; width: 100%; height: 100%; z-index: 1;">
                                    <div style="position: absolute; left: 0; right: 0; top: 0; height: 1px; background: var(--primary-accent); opacity: 0.2;"></div>
                                    <div style="position: absolute; left: 0; right: 0; top: 25%; height: 1px; background: var(--primary-accent); opacity: 0.2;"></div>
                                    <div style="position: absolute; left: 0; right: 0; top: 50%; height: 1px; background: var(--primary-accent); opacity: 0.2;"></div>
                                    <div style="position: absolute; left: 0; right: 0; top: 75%; height: 1px; background: var(--primary-accent); opacity: 0.2;"></div>
                                    <div style="position: absolute; left: 0; right: 0; bottom: 0; height: 1px; background: var(--primary-accent); opacity: 0.2;"></div>
                                </div>
                                <div style="display: flex; justify-content: space-around; height: 100%; position: relative;">
                `;
                
                // Add bars with photos - sci-fi style
                chartData.forEach((item, index) => {
                    const barWidth = 80;
                    
                    chartHTML += `
                        <div style="display: flex; flex-direction: column; align-items: center; position: relative; height: 100%; width: ${barWidth}px;">
                            <!-- Photo at the top of the bar -->
                            <div style="position: absolute; bottom: ${item.heightPercentage}%; margin-bottom: 10px; z-index: 5; display: flex; flex-direction: column; align-items: center;">
                                ${item.photoUrl ? 
                                    `<img src="${item.photoUrl}" class="bar-image" alt="${item.name}" 
                                     onclick="selectStone('${item.stoneId}'); setTimeout(() => { document.getElementById('journeyDetails').scrollIntoView({behavior: 'smooth'}); }, 300);" 
                                     style="margin-bottom: 5px; cursor: pointer;" />` : 
                                    `<div class="bar-image" style="display: flex; align-items: center; justify-content: center; margin-bottom: 5px;">
                                        <span style="color: var(--text-secondary);">No image</span>
                                     </div>`
                                }
                                <div style="font-size: 0.8em; text-align: center; background: rgba(15, 22, 49, 0.7); padding: 3px 8px; border-radius: 10px; border: 1px solid var(--primary-accent); color: var(--primary-accent); font-family: 'Orbitron', sans-serif;">
                                    ${item.journeys} jumps
                                </div>
                            </div>
                            
                            <!-- Bar positioned at the bottom - with glow effect -->
                            <div style="position: absolute; bottom: 0; width: 80%; height: ${item.heightPercentage}%; background: linear-gradient(to top, var(--primary-accent), var(--tertiary-accent)); z-index: 1; border-top-left-radius: 4px; border-top-right-radius: 4px; box-shadow: 0 0 15px rgba(0, 229, 255, 0.3);"></div>
                            <!-- Bar glow overlay -->
                            <div style="position: absolute; bottom: 0; width: 80%; height: ${item.heightPercentage}%; background: var(--primary-accent); z-index: 2; border-top-left-radius: 4px; border-top-right-radius: 4px; opacity: 0.3; filter: blur(5px);"></div>
                        </div>
                    `;
                });
                
                chartHTML += `
                                </div>
                            </div>
                        </div>
                        
                        <!-- X-axis labels in their own container - sci-fi style -->
                        <div style="position: absolute; left: 50px; right: 0; bottom: 0; height: 50px; display: flex; justify-content: space-around;">
                `;
                
                // Add x-axis labels in their own separate container
                chartData.forEach(item => {
                    chartHTML += `
                        <div style="width: 80px; text-align: center; font-weight: bold; font-family: 'Orbitron', sans-serif; color: var(--primary-accent);">
                            ${item.name}
                        </div>
                    `;
                });
                
                chartHTML += `
                        </div>
                    </div>
                `;
                
                chartContainer.innerHTML = chartHTML;
                
            } catch (error) {
                console.error("Error creating top performers chart:", error);
                document.getElementById('topPerformersChart').innerHTML = 
                    `<p style="text-align: center; padding: 40px; color: var(--text-secondary);"><i class="fas fa-exclamation-triangle" style="font-size: 2em; color: var(--danger-color); margin-bottom: 15px; display: block;"></i>ERROR PROCESSING DATA: ${error.message}</p>`;
            }
        }
        
        // Art Gallery Functions
        function initializeGallery() {
            // Create range buttons based on the folder structure
            createGalleryRangeButtons();
        }
        
        function createGalleryRangeButtons() {
            // Clear existing buttons
            const rangeSelector = document.getElementById('galleryRangeSelector');
            rangeSelector.innerHTML = '';
            
            // Get all folder IDs from our existing folder structure
            const folderCards = document.querySelectorAll('.folder-card');
            const folderIds = Array.from(folderCards).map(card => card.dataset.folderId);
            
            // Sort folder IDs numerically
            folderIds.sort((a, b) => {
                const [minA] = a.split('-').map(Number);
                const [minB] = b.split('-').map(Number);
                return minA - minB;
            });
            
            // Add an "All Stones" button - sci-fi style
            const allButton = document.createElement('button');
            allButton.className = 'range-button';
            allButton.innerHTML = '<i class="fas fa-globe-americas"></i> ALL SPECIMENS';
            allButton.dataset.range = 'all';
            allButton.onclick = () => loadGalleryPhotos('all');
            rangeSelector.appendChild(allButton);
            
            // Create range buttons - sci-fi style
            folderIds.forEach(folderId => {
                const [minStone, maxStone] = folderId.split('-');
                const rangeButton = document.createElement('button');
                rangeButton.className = 'range-button';
                rangeButton.innerHTML = `<i class="fas fa-cubes"></i> RANGE ${minStone}-${maxStone}`;
                rangeButton.dataset.range = folderId;
                rangeButton.onclick = () => loadGalleryPhotos(folderId);
                rangeSelector.appendChild(rangeButton);
            });
        }
        
        async function loadGalleryPhotos(rangeId) {
            showLoading();
            
            // Update active button
            document.querySelectorAll('.range-button').forEach(button => {
                button.classList.remove('active');
                if (button.dataset.range === rangeId) {
                    button.classList.add('active');
                }
            });
            
            try {
                const galleryGrid = document.getElementById('galleryGrid');
                galleryGrid.innerHTML = ''; // Clear existing content
                
                // Get all stones that have photos
                let filteredStones = [];
                
                if (rangeId === 'all') {
                    // All stones with photos
                    filteredStones = allStones.filter(stone => stone.hasPhoto);
                } else {
                    // Filter by range
                    const [minStone, maxStone] = rangeId.split('-').map(Number);
                    
                    filteredStones = allStones.filter(stone => {
                        // Extract numeric part from stone ID
                        const stoneIdStr = stone.id.toString();
                        const numericPart = stoneIdStr.replace(/\D/g, '');
                        const stoneNum = parseInt(numericPart);
                        
                        if (isNaN(stoneNum)) return false;
                        return stoneNum >= minStone && stoneNum <= maxStone && stone.hasPhoto;
                    });
                }
                
                console.log(`Found ${filteredStones.length} stones with photos in range ${rangeId}`);
                
                // If no photos found - sci-fi style
                if (filteredStones.length === 0) {
                    galleryGrid.innerHTML = `
                        <div class="no-photos-message">
                            <i class="fas fa-satellite-dish" style="font-size: 2em; color: var(--primary-accent); margin-bottom: 15px; opacity: 0.7;"></i>
                            <p>NO SPECIMEN IMAGES DETECTED IN DATABASE</p>
                            <p style="margin-top: 10px; font-size: 0.9em; color: var(--text-secondary);">SELECT ALTERNATE RANGE OR UPLOAD NEW IMAGERY</p>
                        </div>
                    `;
                    hideLoading();
                    return;
                }
                
                // Sort stones by ID
                filteredStones.sort((a, b) => {
                    const numA = parseInt(a.id.toString().replace(/\D/g, ''));
                    const numB = parseInt(b.id.toString().replace(/\D/g, ''));
                    return numA - numB;
                });
                
                // Create gallery items for each stone with a photo - sci-fi style
                for (const stone of filteredStones) {
                    let photoUrl = stone.photoUrl;
                    
                    // If photoUrl not already available in the stone object, try to fetch it
                    if (!photoUrl) {
                        try {
                            // Check Firestore first
                            const stoneDoc = await db.collection('stones').doc(stone.id.toString()).get();
                            const stoneData = stoneDoc.data() || {};
                            
                            if (stoneData.featurePhoto && stoneData.featurePhoto.url) {
                                photoUrl = stoneData.featurePhoto.url;
                            } else {
                                // Try Storage
                                try {
                                    const storageRef = storage.ref(`stones/${stone.id}/${stone.id}`);
                                    photoUrl = await storageRef.getDownloadURL();
                                } catch (err) {
                                    // No photo available - skip this stone
                                    continue;
                                }
                            }
                        } catch (error) {
                            console.error(`Error getting photo for stone ${stone.id}:`, error);
                            continue;
                        }
                    }
                    
                    // Create gallery item with the photo - sci-fi style
                    const galleryItem = document.createElement('div');
                    galleryItem.className = 'gallery-item';
                    galleryItem.dataset.stoneId = stone.id;
                    galleryItem.innerHTML = `
                        <img src="${photoUrl}" 
                             alt="Stone #${stone.id}" 
                             class="gallery-image"
                             loading="lazy"
                             onclick="openPhotoModal('${photoUrl}')"
                        >
                        <div class="gallery-caption">SPECIMEN #${stone.id}</div>
                    `;
                    
                    // Add click handler to view stone details
                    galleryItem.addEventListener('dblclick', () => {
                        selectStone(stone.id);
                        // Scroll to the stone's journey details
                        setTimeout(() => {
                            document.getElementById('journeyDetails').scrollIntoView({behavior: 'smooth'});
                        }, 500);
                    });
                    
                    galleryGrid.appendChild(galleryItem);
                }
                
                // Add tooltip for double-click info if there are photos - sci-fi style
                if (filteredStones.length > 0) {
                    const infoText = document.createElement('p');
                    infoText.style.textAlign = 'center';
                    infoText.style.color = 'var(--text-secondary)';
                    infoText.style.fontSize = '0.8em';
                    infoText.style.marginTop = '10px';
                    infoText.style.fontFamily = 'Exo 2, sans-serif';
                    infoText.innerHTML = '<i class="fas fa-info-circle"></i> ADVANCED PROTOCOL: Double-click a specimen to view trajectory data';
                    galleryGrid.appendChild(infoText);
                }
                
            } catch (error) {
                console.error("Error loading gallery photos:", error);
                document.getElementById('galleryGrid').innerHTML = `
                    <div class="no-photos-message">
                        <i class="fas fa-exclamation-triangle" style="font-size: 2em; color: var(--danger-color); margin-bottom: 15px;"></i>
                        <p>ERROR ACCESSING IMAGE DATABASE: ${error.message}</p>
                    </div>
                `;
            } finally {
                hideLoading();
            }
        }

        // Initialize the dashboard
        window.onload = () => {
            loadStones(); // This will also initialize the gallery after folders are created
            loadRecentUpdates();
            initMap();
            
            // Load statistics after a short delay to ensure stones are loaded
            setTimeout(() => {
                loadStatistics();
            }, 1500);

            // Event listeners for modal
            document.getElementById('photoModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closePhotoModal();
                }
            });

            // Handle escape key for modal
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closePhotoModal();
                }
            });

            // Handle window resize for maps
            window.addEventListener('resize', function() {
                if (currentMap) {
                    currentMap.invalidateSize();
                }
                if (allStonesMap) {
                    allStonesMap.invalidateSize();
                }
            });
        };
    </script>
</body>
</html>
